
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using DynamicData.Kernel;
using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System.Text.RegularExpressions;
using System.Reflection;
using System.Reflection.Metadata;
using CommandLine;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using ScriptProperty = Mutagen.Bethesda.Skyrim.ScriptProperty;
using VirtualMachineAdapter = Mutagen.Bethesda.Skyrim.VirtualMachineAdapter;
using IQuest = Mutagen.Bethesda.Skyrim.IQuest;
using System.Collections;
using DynamicData;
using Newtonsoft.Json;


// Function to initialize the matches dictionary with all keys set to 0


namespace SpellAbsorptionReworkSynth;

public class Program
{
    private static Lazy<Settings> formSettings = null!;

    static void WriteToIniFile(string filePath, string text)
    {
        // Open the file for appending
        using (StreamWriter writer = new StreamWriter(filePath, true, Encoding.UTF8))
        {
            // Write the text to the file
            writer.WriteLine(text);
        }
    }
    static void ClearFile(string filePath)
    {
        // Open the file for writing and clear its content
        using (StreamWriter writer = new StreamWriter(filePath, false, Encoding.UTF8))
        {
            // Write nothing to the file (effectively clearing its content)
        }
    }
    static DataTable CreateDataTableFromCsv(string filePath)
    {
        DataTable dataTable = new DataTable();

        // Read all lines from the CSV file
        string[] lines = File.ReadAllLines(filePath);

        if (lines.Length > 0)
        {
            // Determine the number of columns based on the first line
            string[] firstLineValues = lines[0].Split(',');

            // Add generic column names (Column1, Column2, etc.)
            for (int col = 0; col < firstLineValues.Length; col++)
            {
                dataTable.Columns.Add("Column" + (col + 1));
            }

            // Add all rows starting from the first line
            foreach (string line in lines)
            {
                string[] values = line.Split(',');
                dataTable.Rows.Add(values);
            }
        }

        return dataTable;
    }


    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetAutogeneratedSettings(
                "Settings",
                "Settings.json",
                out formSettings)
            .SetTypicalOpen(GameRelease.SkyrimSE, "unofficialReqtificatorLite.esp")
            .Run(args);
    }

    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
     
        //Console.WriteLine(mod);
       
        List<string> masterList = new List<string>();
        // Initialize the ignoreList with non-nullable string type to match RFTImasterList
        List<string> ignoreList = new List<string>();

        // Define the path to the file
        string outputPath = $@"{state.DataFolderPath}\SpellAbsorptionRework_AAA_SynthOut_KID.ini";

        
        // Check if the file exists and read it into ignoreList, else create it
        if (File.Exists(outputPath))
        {
            // Read all lines ensuring they are non-null strings
            ignoreList = File.ReadAllLines(outputPath).Where(line => line != null).ToList();
            File.WriteAllText(outputPath, string.Empty);
        }
        else
        {
            // Initialize an empty file to avoid null issues later
            WriteToIniFile(outputPath, "");
        }
        List<string> newEntries = new List<string>();
        // Create a DataTable
        DataTable spellTable = new DataTable();
        spellTable.Columns.Add("pluginName", typeof(string));
        spellTable.Columns.Add("spellExclude", typeof(string));

        foreach (var spell in state.LoadOrder.PriorityOrder.Spell().WinningOverrides())
        {
            try {
                if (spell.Flags.HasFlag(SpellDataFlag.NoAbsorbOrReflect))
                {
                    string pluginName = spell.FormKey.ModKey.FileName.ToString();
                    string spellExclude = spell.FormKey.ToString();

                    // Check if the 7th character (index 6, as indexes start at 0) is ':'
                    if (spellExclude.Length > 6 && spellExclude[6] == ':')
                    {
                        spellExclude = spellExclude.Substring(0, 6) + "~" + spellExclude.Substring(7);
                    }


                    spellTable.Rows.Add(pluginName, spellExclude);

                    // string spellExcludeFull = $@"Keyword = madAbsorbRedoneKeywordRegenIgnore|Spell|0x{spell.FormKey.ToString()}~{spell.FormKey.ModKey.FileName.ToString()}";
                    // newEntries.Add(spellExcludeFull);
                }
            }
            catch { }

           
        }
        // Group by pluginName and print spellExclude values with pluginName included in each entry
        var groupedSpells = spellTable.AsEnumerable()
       .GroupBy(row => row.Field<string>("pluginName"))
       .Select(group => new
       {
           PluginName = group.Key,
           SpellExcludes = string.Join(",", group.Select(row => $"0x{row.Field<string>("spellExclude")}"))
       });

        List<string> formattedLines = new List<string>();

        foreach (var group in groupedSpells)
        {
            string spellExcludeFull = $@"Keyword = madAbsorbRedoneKeywordRegenIgnore|Spell|{group.SpellExcludes}";
            formattedLines.Add(spellExcludeFull);
        }

        // Write the properly formatted grouped data to the file
        if (formattedLines.Count > 0)
        {
            File.AppendAllLines(outputPath, formattedLines);
        }

        // WriteToIniFile(outputPath, newEntries);
        Console.WriteLine($"SpellAbsorptionRework_AAA_SynthOut_KID.ini successfully created.");










    }
}
